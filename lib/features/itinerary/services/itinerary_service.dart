import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:planmapp/features/itinerary/domain/models/activity.dart';

class ItineraryService {
  final SupabaseClient _supabase = Supabase.instance.client;

  Future<List<Activity>> getActivities(String planId) async {
    try {
      final response = await _supabase
          .from('activities')
          .select()
          .eq('plan_id', planId)
          .order('start_time', ascending: true);

      return (response as List).map((e) => Activity.fromJson(e)).toList();
    } catch (e) {
      throw Exception('Error loading itinerary: $e');
    }
  }

  Future<void> createActivity(Activity activity) async {
    try {
      final user = _supabase.auth.currentUser;
      if (user == null) throw Exception("User not authenticated");

      // Note: we don't send 'id' or 'created_at' as they are generated by DB
      await _supabase.from('activities').insert({
        ...activity.toJson(),
        'created_by': user.id,
      });
    } catch (e) {
      throw Exception('Error creating activity: $e');
    }
  }

  Future<void> updateActivity(Activity activity) async {
      try {
          await _supabase.from('activities').update({
              'title': activity.title,
              'description': activity.description,
              'location_name': activity.locationName,
              // 'location': ... (handled via PostGIS usually, or raw lat/long columns. Assuming model handles mapping)
              'start_time': activity.startTime.toIso8601String(),
              'end_time': activity.endTime?.toIso8601String(),
              'category': activity.category.name,
              // Update lat/long columns if your schema separates them
              'latitude': activity.location?.latitude,
              'longitude': activity.location?.longitude,
          }).eq('id', activity.id);
      } catch (e) {
          throw Exception('Error updating activity: $e');
      }
  }

  Future<void> deleteActivity(String activityId) async {
      try {
          await _supabase.from('activities').delete().eq('id', activityId);
      } catch (e) {
          throw Exception('Error deleting activity: $e');
      }
  }

  Future<void> addActivities(List<Activity> activities, String planId) async {
      try {
          final user = _supabase.auth.currentUser;
          if (user == null) throw Exception("User not authenticated");

          final List<Map<String, dynamic>> batch = activities.map((a) {
              final json = a.toJson();
              json['plan_id'] = planId; // Ensure planId is set
              json['created_by'] = user.id;
              // Remove calculated or null fields if necessary, but toJson() handles most.
              // Note: LatLng logic in toJson might differ from direct column insert if table varies
              // but createActivity uses toJson() so we assume it works.
              return json;
          }).toList();

          await _supabase.from('activities').insert(batch);
      } catch (e) {
          throw Exception('Error adding activities: $e');
      }
  }
}
